#ifndef PARSER_H
#define PARSER_H
#include <QObject>
#include "settings.h"
#include "token.h"
#include "abstractsyntaxtree.h"

/**
 * @brief The Parser class parses a token list generated by Lexer and produces an abstract syntax tree.
 */
class Parser : public QObject
{
		Q_OBJECT
	public:
		typedef QList<Token>::ConstIterator TokIterator;
		Parser();

		/**
		 * @brief parse Parses a token list and generates an AST
		 * @param tokens Token list
		 * @return The abstract syntax tree generated
		 */
		ast::Program *parse(const QList<Token> &tokens, const Settings &settings);

		/**
		 * @brief success
		 * @return True, if parsing succeeded, false otherwise.
		 */
		bool success() {return mStatus == Ok;}

		ast::ConstDefinition *tryConstDefinition(TokIterator &i);
		ast::GlobalDefinition *tryGlobalDefinition(TokIterator &i);
		QString tryVariableTypeDefinition(TokIterator &i);
		QString tryVariableTypeMark(TokIterator &i);
		QString tryVariableAsType(TokIterator &i);
		ast::Node *tryReturn(TokIterator &i);
		ast::TypeDefinition *tryTypeDefinition(TokIterator &i);
		ast::Variable *expectVariable(TokIterator &i);
		ast::Variable *tryVariable(TokIterator &i);
		ast::Node *trySelectStatement(TokIterator &i);
		ast::Node *tryGotoGosubAndLabel(TokIterator &i);
		ast::Node *tryRedim(TokIterator &i);
		void expectVariable(ast::Variable *var, TokIterator &i);
		ast::Node *tryDim(TokIterator &i);
		ast::Node *tryIfStatement(TokIterator &i);
		ast::Node *expectElseIfStatement(TokIterator &i);
		ast::Node *tryWhileStatement(TokIterator &i);
		ast::Node *tryRepeatStatement(TokIterator &i);
		ast::Node *tryForStatement(TokIterator &i);
		ast::Node *tryFunctionOrCommandCallOrArraySubscriptAssignment(TokIterator &i);
		ast::Block expectBlock(TokIterator &i);
		ast::Block expectInlineBlock(TokIterator &i);

		ast::FunctionDefinition *tryFunctionDefinition(TokIterator &i);
		ast::FunctionParametreDefinition expectFunctionParametreDefinition(TokIterator &i);

		ast::Node *expectExpression(TokIterator &i);
		ast::Node *expectLogicalOrExpression(TokIterator &i);
		ast::Node *expectLogicalAndExpression(TokIterator &i);
		ast::Node *expectEqualityExpression(TokIterator &i);
		ast::Node *expectRelativeExpression(TokIterator &i);
		ast::Node *expectBitShiftExpression(TokIterator &i);
		ast::Node *expectAdditiveExpression(TokIterator &i);
		ast::Node *expectMultiplicativeExpression(TokIterator &i);
		ast::Node *expectPowExpression(TokIterator &i);
		ast::Node *expectUnaryExpession(TokIterator &i);
		ast::Node *expectPrimaryExpression(TokIterator &i);
		ast::Node *tryAssignmentExpression(TokIterator &i);
		QString expectIdentifier(TokIterator &i);
		QString expectIdentifierAfter(TokIterator &i, const QString &after);
		void expectEndOfStatement(TokIterator &i);
	private:
		enum Status {
			Error,
			ErrorButContinue,
			Ok
		};

		Status mStatus;
		Settings mSettings;

		QString mStringValueTypeName;
		QString mFloatValueTypeName;
		QString mIntegerValueTypeName;
	signals:
		void error(int code, QString msg, int line, QString file);
		void warning(int code, QString msg, int line, QString file);
};

#endif // PARSER_H
